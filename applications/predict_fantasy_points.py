# applications/predict_fantasy_points.py
import xgboost as xgb
import polars as pl
import json
import sys
import joblib
import numpy as np

def load_model_and_features(model_path, feature_names_path=None):
    """Loads the XGBoost model from a .joblib file and DEFINITIVELY gets feature names."""
    try:
        print(f"Loading XGBoost model from Joblib file: {model_path}")
        model = joblib.load(model_path)
        print("Model loaded successfully.")

        if not isinstance(model, (xgb.XGBRegressor, xgb.XGBClassifier)):
             print(f"Warning: Loaded object is type {type(model)}.", file=sys.stderr)

        # --- Get Feature Names Directly From Model ---
        trained_feature_names = None
        if hasattr(model, 'feature_names_in_'):
            trained_feature_names = model.feature_names_in_
            if trained_feature_names is not None:
                 trained_feature_names = list(trained_feature_names) # Ensure it's a list
                 print(f"Successfully loaded {len(trained_feature_names)} feature names from model object.")
                 # --- Print for verification ---
                 print("\n--- Feature Names Expected by Model ---")
                 print(json.dumps(trained_feature_names, indent=2))
                 print("--- End Feature Names ---")
                 # --- Save to JSON (Optional but Recommended) ---
                 if feature_names_path:
                      try:
                           print(f"\nSaving exact feature names to: {feature_names_path}")
                           with open(feature_names_path, 'w') as f:
                                json.dump(trained_feature_names, f, indent=2)
                           print("Feature names saved.")
                      except Exception as e:
                           print(f"Warning: Could not save feature names to {feature_names_path}: {e}", file=sys.stderr)

        # Fallback/Error if names couldn't be loaded
        if trained_feature_names is None:
             # Try inferring from booster (less reliable)
             if hasattr(model, 'get_booster'):
                  try:
                      trained_feature_names = model.get_booster().feature_names
                      if trained_feature_names:
                           print(f"Inferred {len(trained_feature_names)} feature names from booster (might be less reliable).")
                           print("\n--- Feature Names Expected by Model (Inferred) ---")
                           print(json.dumps(trained_feature_names, indent=2))
                           print("--- End Feature Names ---")
                      else:
                          raise ValueError("Booster had no feature names.")
                  except Exception:
                      raise ValueError("Could not get feature names from model object or booster.")
             else:
                  raise ValueError("Model object does not have 'feature_names_in_' and cannot infer names.")

        if not trained_feature_names: # Should be caught above, but safety check
            raise ValueError("Failed to obtain the list of trained feature names.")

        print(f"\nModel expects exactly {len(trained_feature_names)} features.")
        return model, trained_feature_names

    # ... (rest of error handling) ...
    except FileNotFoundError:
        print(f"Fatal Error: Model file not found at {model_path}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
         print(f"Fatal Error: An unexpected error occurred loading model/features: {e}", file=sys.stderr)
         sys.exit(1)
# --- (predict_points function remains the same) ---
# applications/predict_fantasy_points.py
# ... (imports and load_model_and_features function) ...

def predict_points(model, trained_feature_names, generated_features_dict):
    """
    Prepares features (including imputation for missing ones)
    and makes a prediction using the loaded model.
    """
    if not generated_features_dict:
        print("Error: Received empty features dictionary.", file=sys.stderr)
        return None

    # --- Prepare Features for Prediction ---
    try:
        # Create DataFrame row using ALL expected feature names
        feature_data = {}
        missing_features_imputed = []
        generated_feature_keys = generated_features_dict.keys()

        # Iterate through the DEFINITIVE list of features the model expects
        for feature_name in trained_feature_names:
            if feature_name in generated_feature_keys:
                # Use the value generated by rag-features.py
                value = generated_features_dict[feature_name]
                # Basic check for NaN/None within generated features, default to 0.0
                if value is None or (isinstance(value, float) and np.isnan(value)):
                     feature_data[feature_name] = [0.0]
                else:
                     feature_data[feature_name] = [value]
            else:
                # Feature was expected by model but NOT generated by rag-features.py
                # Impute with 0.0
                feature_data[feature_name] = [0.0]
                missing_features_imputed.append(feature_name)

        if missing_features_imputed:
             # This is now expected behavior, make it an INFO message
             print(f"[INFO] Imputed {len(missing_features_imputed)} missing features with 0.0: {missing_features_imputed}")

        # Create the DataFrame - it will have exactly the columns the model expects
        feature_df_pred = pl.DataFrame(feature_data)

        # Ensure columns are in the exact order (redundant if using dict keys, but safe)
        feature_df_pred = feature_df_pred.select(trained_feature_names)

        # Convert to NumPy array
        features_for_xgb = feature_df_pred.to_numpy()

    except Exception as e:
         print(f"Error preparing features for prediction: {e}", file=sys.stderr)
         return None

    # --- Make Prediction (remains the same) ---
    try:
        prediction = model.predict(features_for_xgb)
        predicted_points = prediction[0]
        return float(predicted_points)
    except Exception as e:
         # Check for the specific mismatch error again, although it shouldn't happen now
         if "Feature shape mismatch" in str(e):
              print(f"Error during prediction: {e}. Input shape: {features_for_xgb.shape}", file=sys.stderr)
              print(f"Model expected features: {trained_feature_names}", file=sys.stderr)
         else:
              print(f"Error during prediction: {e}", file=sys.stderr)
         return None


# --- (if __name__ == "__main__": block can remain the same or be updated) ---
if __name__ == "__main__":
    # Update paths
    test_model_path = '../model_training/models/tuned_xgboost_baseline(.56 mae).joblib'
    test_feature_names_path = '../model_training/models/feature_names.json' # Let the function load/save this

    # Load model and DEFINITIVE feature names
    model_object, model_feature_names = load_model_and_features(test_model_path, test_feature_names_path)

    # --- Dummy Data MUST NOW MATCH the 48 GENERATED features ---
    # The predict_points function will handle adding the missing 14
    test_features_generated = { # Only include features rag-features.py CAN produce
        'age': 27, 'years_exp': 4, 'draft_ovr': 53, # Example values
        'offense_snaps': 60.0, 'offense_pct': 0.9, 'touches': 15.0, 'targets': 0.0,
        'receptions': 0.0, 'rush_attempts': 11.0, 'pass_attempts': 35.0,
        'receiving_yards': 0.0, 'rushing_yards': 50.0, 'yards_after_catch': 0.0,
        'passing_air_yards': 300.0, 'receiving_air_yards': 0.0, 'adot': 0.0,
        'yptouch': 3.33, 'passer_rating': 95.0, 'ypc': 4.5, 'ypr': 0.0,
        'interception': 1.0, 'rush_attempts_redzone': 2.0, 'targets_redzone': 0.0,
        'pass_attempts_redzone': 5.0, 'receiving_touchdown': 0.0, 'rush_touchdown': 1.0,
        'shotgun': 0.8, 'no_huddle': 0.1, 'pass_pct': 65.0, 'total_off_yards': 350.0,
        'rolling_avg_points_allowed_4_weeks': 25.28, 'rolling_avg_passing_yards_allowed_4_weeks': 261.0,
        'rolling_avg_rushing_yards_allowed_4_weeks': 130.7, 'rolling_avg_sack_4_weeks': 2.0,
        'rolling_avg_interception_4_weeks': 0.57, '3_game_avg_offense_pct': 0.85,
        '3_game_avg_targets': 0.0, '3_game_avg_receptions': 0.0, '3_game_avg_rush_attempts': 10.0,
        '3_game_avg_receiving_yards': 0.0, '3_game_avg_rushing_yards': 45.0,
        '3_game_avg_y_fantasy_points_ppr': 21.38,
        'position_QB': 1, 'position_RB': 0, 'position_TE': 0, 'position_WR': 0, # OHE Position
        'is_home': 1, 'is_active': 1
    }


    if model_object:
         print(f"\nRunning test prediction with {len(test_features_generated)} generated features...")
         prediction_result = predict_points(model_object, model_feature_names, test_features_generated) # Use the loaded names

         if prediction_result is not None:
              print("\n--- Direct Script Test Prediction ---")
              print(f"Predicted Points: {prediction_result:.2f}")